{"ast":null,"code":"import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Camera } from '../core/Camera.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { NormalProgram } from './NormalProgram.js';\nimport { InstancedMesh } from './InstancedMesh.js';\n\n// TODO\n// [ ] Morph targets\n// [ ] Materials\n// [ ] Sparse accessor packing? For morph targets basically\n// [ ] Option to turn off GPU instancing?\n// [ ] Spot lights\n\nconst TYPE_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n  'image/jpeg': Uint8Array,\n  'image/png': Uint8Array,\n  'image/webp': Uint8Array\n};\nconst TYPE_SIZE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst TRANSFORMS = {\n  translation: 'position',\n  rotation: 'quaternion',\n  scale: 'scale'\n};\nexport class GLTFLoader {\n  static setDracoManager(manager) {\n    this.dracoManager = manager;\n  }\n  static setBasisManager(manager) {\n    this.basisManager = manager;\n  }\n  static async load(gl, src) {\n    const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n    // Load main description json\n    const desc = await this.parseDesc(src);\n    return this.parse(gl, desc, dir);\n  }\n  static async parse(gl, desc, dir) {\n    if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n    if (desc.extensionsRequired?.includes('KHR_draco_mesh_compression') && !this.dracoManager) console.warn('KHR_draco_mesh_compression extension required but no manager supplied. Use .setDracoManager()');\n    if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager) console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n    // Load buffers async\n    const buffers = await this.loadBuffers(desc, dir);\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    gl.renderer.bindVertexArray(null);\n\n    // Create gl buffers from bufferViews\n    const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n    // Create images from either bufferViews or separate image files\n    const images = await this.parseImages(gl, desc, dir, bufferViews);\n    const textures = this.parseTextures(gl, desc, images);\n\n    // Just pass through material data for now\n    const materials = this.parseMaterials(gl, desc, textures);\n\n    // Fetch the inverse bind matrices for skeleton joints\n    const skins = this.parseSkins(gl, desc, bufferViews);\n\n    // Create geometries for each mesh primitive\n    const meshes = await this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n    // Create transforms, meshes and hierarchy\n    const [nodes, cameras] = this.parseNodes(gl, desc, meshes, skins, images);\n\n    // Place nodes in skeletons\n    this.populateSkins(skins, nodes);\n\n    // Create animation handlers\n    const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n    // Get top level nodes for each scene\n    const scenes = this.parseScenes(desc, nodes);\n    const scene = scenes[desc.scene];\n\n    // Create uniforms for scene lights (TODO: light linking?)\n    const lights = this.parseLights(gl, desc, nodes, scenes);\n\n    // Remove null nodes (instanced transforms)\n    for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n    return {\n      json: desc,\n      buffers,\n      bufferViews,\n      cameras,\n      images,\n      textures,\n      materials,\n      meshes,\n      nodes,\n      lights,\n      animations,\n      scenes,\n      scene\n    };\n  }\n  static parseDesc(src) {\n    return fetch(src, {\n      mode: 'cors'\n    }).then(res => res.arrayBuffer()).then(data => {\n      const textDecoder = new TextDecoder();\n      if (textDecoder.decode(new Uint8Array(data, 0, 4)) === 'glTF') {\n        return this.unpackGLB(data);\n      } else {\n        return JSON.parse(textDecoder.decode(data));\n      }\n    });\n  }\n\n  // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n  static unpackGLB(glb) {\n    // Decode and verify GLB header\n    const header = new Uint32Array(glb, 0, 3);\n    if (header[0] !== 0x46546c67) {\n      throw new Error('Invalid glTF asset.');\n    } else if (header[1] !== 2) {\n      throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n    }\n    // Decode and verify chunk headers\n    const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n    const jsonByteOffset = 20;\n    const jsonByteLength = jsonChunkHeader[0];\n    if (jsonChunkHeader[1] !== 0x4e4f534a) {\n      throw new Error('Unexpected GLB layout.');\n    }\n\n    // Decode JSON\n    const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n    const json = JSON.parse(jsonText);\n    // JSON only\n    if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n    const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n    if (binaryChunkHeader[1] !== 0x004e4942) {\n      throw new Error('Unexpected GLB layout.');\n    }\n    // Decode content\n    const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n    const binaryByteLength = binaryChunkHeader[0];\n    const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n    // Attach binary to buffer\n    json.buffers[0].binary = binary;\n    return json;\n  }\n\n  // ThreeJS GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n  static resolveURI(uri, dir) {\n    // Invalid URI\n    if (typeof uri !== 'string' || uri === '') return '';\n\n    // Host Relative URI\n    if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n      dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    }\n\n    // Absolute URI http://, https://, //\n    if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n    // Data URI\n    if (/^data:.*,.*$/i.test(uri)) return uri;\n\n    // Blob URI\n    if (/^blob:.*$/i.test(uri)) return uri;\n\n    // Relative URI\n    return dir + uri;\n  }\n  static loadBuffers(desc, dir) {\n    if (!desc.buffers) return null;\n    return Promise.all(desc.buffers.map(buffer => {\n      // For GLB, binary buffer ready to go\n      if (buffer.binary) return buffer.binary;\n      const uri = this.resolveURI(buffer.uri, dir);\n      return fetch(uri, {\n        mode: 'cors'\n      }).then(res => res.arrayBuffer());\n    }));\n  }\n  static parseBufferViews(gl, desc, buffers) {\n    if (!desc.bufferViews) return null;\n    const bufferViews = desc.bufferViews;\n    desc.meshes && desc.meshes.forEach(_ref => {\n      let {\n        primitives\n      } = _ref;\n      primitives.forEach(_ref2 => {\n        let {\n          attributes,\n          indices,\n          extensions\n        } = _ref2;\n        // Flag bufferView as an attribute, so it knows to create a gl buffer\n        for (const attr in attributes) {\n          const accessor = desc.accessors[attributes[attr]];\n          if (accessor.bufferView === undefined && !!extensions) {\n            // Draco extension buffer view\n            if (extensions.KHR_draco_mesh_compression) {\n              accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n              bufferViews[accessor.bufferView].isDraco = true;\n            }\n          }\n          bufferViews[accessor.bufferView].isAttribute = true;\n        }\n        if (indices !== undefined) {\n          const accessor = desc.accessors[indices];\n          if (accessor.bufferView === undefined && !!extensions) {\n            // Draco extension buffer view\n            if (extensions.KHR_draco_mesh_compression) {\n              accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n              bufferViews[accessor.bufferView].isDraco = true;\n            }\n          }\n          bufferViews[accessor.bufferView].isAttribute = true;\n\n          // Make sure indices bufferView have a target property for gl buffer binding\n          bufferViews[accessor.bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n        }\n      });\n    });\n\n    // Get componentType of each bufferView from the accessors\n    desc.accessors.forEach(_ref3 => {\n      let {\n        bufferView: bufferViewIndex,\n        componentType\n      } = _ref3;\n      if (bufferViewIndex === undefined) return;\n      bufferViews[bufferViewIndex].componentType = componentType;\n    });\n\n    // Get mimetype of bufferView from images\n    desc.images && desc.images.forEach(_ref4 => {\n      let {\n        uri,\n        bufferView: bufferViewIndex,\n        mimeType\n      } = _ref4;\n      if (bufferViewIndex === undefined) return;\n      bufferViews[bufferViewIndex].mimeType = mimeType;\n    });\n\n    // Push each bufferView to the GPU as a separate buffer\n    bufferViews.forEach((_ref5, i) => {\n      let {\n        buffer: bufferIndex,\n        // required\n        byteOffset = 0,\n        // optional\n        byteLength,\n        // required\n        byteStride,\n        // optional\n        target = gl.ARRAY_BUFFER,\n        // optional, added above for elements\n        name,\n        // optional\n        extensions,\n        // optional\n        extras,\n        // optional\n\n        componentType,\n        // optional, added from accessor above\n        mimeType,\n        // optional, added from images above\n        isAttribute,\n        isDraco\n      } = _ref5;\n      bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n      if (!isAttribute || isDraco) return;\n      // Create gl buffers for the bufferView, pushing it to the GPU\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(target, buffer);\n      gl.renderer.state.boundBuffer = buffer;\n      gl.bufferData(target, bufferViews[i].data, gl.STATIC_DRAW);\n      bufferViews[i].buffer = buffer;\n    });\n    return bufferViews;\n  }\n  static parseImages(gl, desc, dir, bufferViews) {\n    if (!desc.images) return null;\n    return Promise.all(desc.images.map(async _ref6 => {\n      let {\n        uri,\n        bufferView: bufferViewIndex,\n        mimeType,\n        name\n      } = _ref6;\n      if (mimeType === 'image/ktx2') {\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const image = await this.basisManager.parseTexture(data);\n        return image;\n      }\n\n      // jpg / png / webp\n      const image = new Image();\n      image.name = name;\n      if (uri) {\n        image.src = this.resolveURI(uri, dir);\n      } else if (bufferViewIndex !== undefined) {\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const blob = new Blob([data], {\n          type: mimeType\n        });\n        image.src = URL.createObjectURL(blob);\n      }\n      image.ready = new Promise(res => {\n        image.onload = () => res();\n      });\n      return image;\n    }));\n  }\n  static parseTextures(gl, desc, images) {\n    if (!desc.textures) return null;\n    return desc.textures.map(textureInfo => this.createTexture(gl, desc, images, textureInfo));\n  }\n  static createTexture(gl, desc, images, _ref7) {\n    let {\n      sampler: samplerIndex,\n      source: sourceIndex,\n      name,\n      extensions,\n      extras\n    } = _ref7;\n    if (sourceIndex === undefined && !!extensions) {\n      // WebP extension source index\n      if (extensions.EXT_texture_webp) sourceIndex = extensions.EXT_texture_webp.source;\n\n      // Basis extension source index\n      if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n    }\n    const image = images[sourceIndex];\n    if (image.texture) return image.texture;\n    const options = {\n      flipY: false,\n      wrapS: gl.REPEAT,\n      // Repeat by default, opposed to OGL's clamp by default\n      wrapT: gl.REPEAT\n    };\n    const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n    if (sampler) {\n      ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach(prop => {\n        if (sampler[prop]) options[prop] = sampler[prop];\n      });\n    }\n\n    // For compressed textures\n    if (image.isBasis) {\n      options.image = image;\n      options.internalFormat = image.internalFormat;\n      if (image.isCompressedTexture) {\n        options.generateMipmaps = false;\n        if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n      }\n      const texture = new Texture(gl, options);\n      texture.name = name;\n      image.texture = texture;\n      return texture;\n    }\n    const texture = new Texture(gl, options);\n    texture.name = name;\n    image.texture = texture;\n    image.ready.then(() => {\n      texture.image = image;\n    });\n    return texture;\n  }\n  static parseMaterials(gl, desc, textures) {\n    if (!desc.materials) return null;\n    return desc.materials.map(_ref8 => {\n      let {\n        name,\n        extensions,\n        extras,\n        pbrMetallicRoughness = {},\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor = [0, 0, 0],\n        alphaMode = 'OPAQUE',\n        alphaCutoff = 0.5,\n        doubleSided = false\n      } = _ref8;\n      const {\n        baseColorFactor = [1, 1, 1, 1],\n        baseColorTexture,\n        metallicFactor = 1,\n        roughnessFactor = 1,\n        metallicRoughnessTexture\n        //   extensions,\n        //   extras,\n      } = pbrMetallicRoughness;\n      if (baseColorTexture) {\n        baseColorTexture.texture = textures[baseColorTexture.index];\n        // texCoord\n      }\n      if (normalTexture) {\n        normalTexture.texture = textures[normalTexture.index];\n        // scale: 1\n        // texCoord\n      }\n      if (metallicRoughnessTexture) {\n        metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n        // texCoord\n      }\n      if (occlusionTexture) {\n        occlusionTexture.texture = textures[occlusionTexture.index];\n        // strength 1\n        // texCoord\n      }\n      if (emissiveTexture) {\n        emissiveTexture.texture = textures[emissiveTexture.index];\n        // texCoord\n      }\n      return {\n        name,\n        extensions,\n        extras,\n        baseColorFactor,\n        baseColorTexture,\n        metallicFactor,\n        roughnessFactor,\n        metallicRoughnessTexture,\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor,\n        alphaMode,\n        alphaCutoff,\n        doubleSided\n      };\n    });\n  }\n  static parseSkins(gl, desc, bufferViews) {\n    if (!desc.skins) return null;\n    return desc.skins.map(_ref9 => {\n      let {\n        inverseBindMatrices,\n        // optional\n        skeleton,\n        // optional\n        joints // required\n        // name,\n        // extensions,\n        // extras,\n      } = _ref9;\n      return {\n        inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n        skeleton,\n        joints\n      };\n    });\n  }\n  static parseMeshes(gl, desc, bufferViews, materials, skins) {\n    if (!desc.meshes) return null;\n    return Promise.all(desc.meshes.map(async (_ref0, meshIndex) => {\n      let {\n        primitives,\n        // required\n        weights,\n        // optional\n        name,\n        // optional\n        extensions,\n        // optional\n        extras = {} // optional - will get merged with node extras\n      } = _ref0;\n      // TODO: weights stuff?\n      // Parse through nodes to see how many instances there are and if there is a skin attached\n      // If multiple instances of a skin, need to create each\n      let numInstances = 0;\n      let skinIndices = [];\n      let isLightmap = false;\n      desc.nodes && desc.nodes.forEach(_ref1 => {\n        let {\n          mesh,\n          skin,\n          extras\n        } = _ref1;\n        if (mesh === meshIndex) {\n          numInstances++;\n          if (skin !== undefined) skinIndices.push(skin);\n          if (extras && extras.lightmap_scale_offset) isLightmap = true;\n        }\n      });\n      let isSkin = !!skinIndices.length;\n\n      // For skins, return array of skin meshes to account for multiple instances\n      if (isSkin) {\n        primitives = await Promise.all(skinIndices.map(async skinIndex => {\n          return (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, 1, isLightmap)).map(_ref10 => {\n            let {\n              geometry,\n              program,\n              mode\n            } = _ref10;\n            const mesh = new GLTFSkin(gl, {\n              skeleton: skins[skinIndex],\n              geometry,\n              program,\n              mode\n            });\n            mesh.name = name;\n            mesh.extras = extras;\n            if (extensions) mesh.extensions = extensions;\n            // TODO: support skin frustum culling\n            mesh.frustumCulled = false;\n            return mesh;\n          });\n        }));\n        // For retrieval to add to node\n        primitives.instanceCount = 0;\n        primitives.numInstances = numInstances;\n      } else {\n        primitives = (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap)).map(_ref11 => {\n          let {\n            geometry,\n            program,\n            mode\n          } = _ref11;\n          // InstancedMesh class has custom frustum culling for instances\n          const meshConstructor = geometry.attributes.instanceMatrix ? InstancedMesh : Mesh;\n          const mesh = new meshConstructor(gl, {\n            geometry,\n            program,\n            mode\n          });\n          mesh.name = name;\n          mesh.extras = extras;\n          if (extensions) mesh.extensions = extensions;\n          // Tag mesh so that nodes can add their transforms to the instance attribute\n          mesh.numInstances = numInstances;\n          return mesh;\n        });\n      }\n      return {\n        primitives,\n        weights,\n        name\n      };\n    }));\n  }\n  static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap) {\n    return Promise.all(primitives.map(async _ref12 => {\n      let {\n        attributes,\n        // required\n        indices,\n        // optional\n        material: materialIndex,\n        // optional\n        mode = 4,\n        // optional\n        targets,\n        // optional\n        extensions,\n        // optional\n        extras // optional\n      } = _ref12;\n      // TODO: materials\n      const program = new NormalProgram(gl);\n      if (materialIndex !== undefined) {\n        program.gltfMaterial = materials[materialIndex];\n      }\n      const geometry = new Geometry(gl);\n      if (extras) geometry.extras = extras;\n      if (extensions) geometry.extensions = extensions;\n\n      // For compressed geometry data\n      if (extensions && extensions.KHR_draco_mesh_compression) {\n        const bufferViewIndex = extensions.KHR_draco_mesh_compression.bufferView;\n        const gltfAttributeMap = extensions.KHR_draco_mesh_compression.attributes;\n        const attributeMap = {};\n        const attributeTypeMap = {};\n        const attributeTypeNameMap = {};\n        const attributeNormalizedMap = {};\n        for (const attr in attributes) {\n          const accessor = desc.accessors[attributes[attr]];\n          const attributeName = ATTRIBUTES[attr];\n          attributeMap[attributeName] = gltfAttributeMap[attr];\n          attributeTypeMap[attributeName] = accessor.componentType;\n          attributeTypeNameMap[attributeName] = TYPE_ARRAY[accessor.componentType].name;\n          attributeNormalizedMap[attributeName] = accessor.normalized === true;\n        }\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const geometryData = await this.dracoManager.decodeGeometry(data, {\n          attributeIds: attributeMap,\n          attributeTypes: attributeTypeNameMap\n        });\n\n        // Add each attribute result\n        for (let i = 0; i < geometryData.attributes.length; i++) {\n          const result = geometryData.attributes[i];\n          const name = result.name;\n          const data = result.array;\n          const size = result.itemSize;\n          const type = attributeTypeMap[name];\n          const normalized = attributeNormalizedMap[name];\n\n          // Create gl buffers for the attribute data, pushing it to the GPU\n          const buffer = gl.createBuffer();\n          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n          gl.renderer.state.boundBuffer = buffer;\n          gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n          geometry.addAttribute(name, {\n            data,\n            size,\n            type,\n            normalized,\n            buffer\n          });\n        }\n\n        // Add index attribute if found\n        if (geometryData.index) {\n          const data = geometryData.index.array;\n          const size = geometryData.index.itemSize;\n\n          // Create gl buffers for the index attribute data, pushing it to the GPU\n          const buffer = gl.createBuffer();\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n          gl.renderer.state.boundBuffer = buffer;\n          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);\n          geometry.addAttribute('index', {\n            data,\n            size,\n            type: 5125,\n            // Uint32Array\n            normalized: false,\n            buffer\n          });\n        }\n      } else {\n        // Add each attribute found in primitive\n        for (const attr in attributes) {\n          geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n        }\n\n        // Add index attribute if found\n        if (indices !== undefined) {\n          geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n        }\n      }\n\n      // Add instanced transform attribute if multiple instances\n      // Ignore if skin as we don't support instanced skins out of the box\n      if (numInstances > 1) {\n        geometry.addAttribute('instanceMatrix', {\n          instanced: 1,\n          size: 16,\n          data: new Float32Array(numInstances * 16)\n        });\n      }\n\n      // Always supply lightmapScaleOffset as an instanced attribute\n      // Instanced skin lightmaps not supported\n      if (isLightmap) {\n        geometry.addAttribute('lightmapScaleOffset', {\n          instanced: 1,\n          size: 4,\n          data: new Float32Array(numInstances * 4)\n        });\n      }\n      return {\n        geometry,\n        program,\n        mode\n      };\n    }));\n  }\n  static parseAccessor(index, desc, bufferViews) {\n    // TODO: init missing bufferView with 0s\n    // TODO: support sparse\n\n    const {\n      bufferView: bufferViewIndex,\n      // optional\n      byteOffset = 0,\n      // optional\n      componentType,\n      // required\n      normalized = false,\n      // optional\n      count,\n      // required\n      type,\n      // required\n      min,\n      // optional\n      max,\n      // optional\n      sparse // optional\n      // name, // optional\n      // extensions, // optional\n      // extras, // optional\n    } = desc.accessors[index];\n    const {\n      data,\n      // attached in parseBufferViews\n      buffer,\n      // replaced to be the actual GL buffer\n      byteOffset: bufferByteOffset = 0,\n      // byteLength, // applied in parseBufferViews\n      byteStride = 0,\n      target\n      // name,\n      // extensions,\n      // extras,\n    } = bufferViews[bufferViewIndex];\n    const size = TYPE_SIZE[type];\n\n    // Parse data from joined buffers\n    const TypeArray = TYPE_ARRAY[componentType];\n    const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n    const componentStride = byteStride / elementBytes;\n    const isInterleaved = !!byteStride && componentStride !== size;\n    let filteredData;\n\n    // Convert data to typed array for various uses (bounding boxes, raycasting, animation, merging etc)\n    if (isInterleaved) {\n      // First convert entire buffer to type\n      const typedData = new TypeArray(data, byteOffset);\n      // TODO: add length to not copy entire buffer if can help it\n      // const typedData = new TypeArray(data, byteOffset, (count - 1) * componentStride)\n\n      // Create output with length\n      filteredData = new TypeArray(count * size);\n\n      // Add element by element\n      for (let i = 0; i < count; i++) {\n        const start = componentStride * i;\n        const end = start + size;\n        filteredData.set(typedData.slice(start, end), i * size);\n      }\n    } else {\n      // Simply a slice\n      filteredData = new TypeArray(data, byteOffset, count * size);\n    }\n\n    // Return attribute data\n    return {\n      data: filteredData,\n      size,\n      type: componentType,\n      normalized,\n      buffer,\n      stride: byteStride,\n      offset: byteOffset,\n      count,\n      min,\n      max\n    };\n  }\n  static parseNodes(gl, desc, meshes, skins, images) {\n    if (!desc.nodes) return null;\n    const cameras = [];\n    const nodes = desc.nodes.map(_ref13 => {\n      let {\n        camera,\n        // optional\n        children,\n        // optional\n        skin: skinIndex,\n        // optional\n        matrix,\n        // optional\n        mesh: meshIndex,\n        // optional\n        rotation,\n        // optional\n        scale,\n        // optional\n        translation,\n        // optional\n        weights,\n        // optional\n        name,\n        // optional\n        extensions,\n        // optional\n        extras // optional\n      } = _ref13;\n      const isCamera = camera !== undefined;\n      const node = isCamera ? new Camera(gl) : new Transform();\n      if (isCamera) {\n        // NOTE: chose to use node's name and extras/extensions over camera\n        const cameraOpts = desc.cameras[camera];\n        if (cameraOpts.type === 'perspective') {\n          const {\n            yfov: fov,\n            znear: near,\n            zfar: far\n          } = cameraOpts.perspective;\n          node.perspective({\n            fov: fov * (180 / Math.PI),\n            near,\n            far\n          });\n        } else {\n          const {\n            xmag,\n            ymag,\n            znear: near,\n            zfar: far\n          } = cameraOpts.orthographic;\n          node.orthographic({\n            near,\n            far,\n            left: -xmag,\n            right: xmag,\n            top: -ymag,\n            bottom: ymag\n          });\n        }\n        cameras.push(node);\n      }\n      if (name) node.name = name;\n      if (extras) node.extras = extras;\n      if (extensions) node.extensions = extensions;\n\n      // Need to attach to node as may have same material but different lightmap\n      if (extras && extras.lightmapTexture !== undefined) {\n        extras.lightmapTexture.texture = this.createTexture(gl, desc, images, {\n          source: extras.lightmapTexture.index\n        });\n      }\n\n      // Apply transformations\n      if (matrix) {\n        node.matrix.copy(matrix);\n        node.decompose();\n      } else {\n        if (rotation) node.quaternion.copy(rotation);\n        if (scale) node.scale.copy(scale);\n        if (translation) node.position.copy(translation);\n        node.updateMatrix();\n      }\n\n      // Flags for avoiding duplicate transforms and removing unused instance nodes\n      let isInstanced = false;\n      let isFirstInstance = true;\n      let isInstancedMatrix = false;\n      let isSkin = skinIndex !== undefined;\n\n      // Add mesh if included\n      if (meshIndex !== undefined) {\n        if (isSkin) {\n          meshes[meshIndex].primitives[meshes[meshIndex].primitives.instanceCount].forEach(mesh => {\n            if (extras) Object.assign(mesh.extras, extras);\n            mesh.setParent(node);\n          });\n          meshes[meshIndex].primitives.instanceCount++;\n          // Remove properties once all instances added\n          if (meshes[meshIndex].primitives.instanceCount === meshes[meshIndex].primitives.numInstances) {\n            delete meshes[meshIndex].primitives.numInstances;\n            delete meshes[meshIndex].primitives.instanceCount;\n          }\n        } else {\n          meshes[meshIndex].primitives.forEach(mesh => {\n            if (extras) Object.assign(mesh.extras, extras);\n\n            // Instanced mesh might only have 1\n            if (mesh.geometry.isInstanced) {\n              isInstanced = true;\n              if (!mesh.instanceCount) {\n                mesh.instanceCount = 0;\n              } else {\n                isFirstInstance = false;\n              }\n              if (mesh.geometry.attributes.instanceMatrix) {\n                isInstancedMatrix = true;\n                node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n              }\n              if (mesh.geometry.attributes.lightmapScaleOffset) {\n                mesh.geometry.attributes.lightmapScaleOffset.data.set(extras.lightmap_scale_offset, mesh.instanceCount * 4);\n              }\n              mesh.instanceCount++;\n              if (mesh.instanceCount === mesh.numInstances) {\n                // Remove properties once all instances added\n                delete mesh.numInstances;\n                delete mesh.instanceCount;\n                // Flag attribute as dirty\n                if (mesh.geometry.attributes.instanceMatrix) {\n                  mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                }\n                if (mesh.geometry.attributes.lightmapScaleOffset) {\n                  mesh.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                }\n              }\n            }\n\n            // For instances, only the first node will actually have the mesh\n            if (isInstanced) {\n              if (isFirstInstance) mesh.setParent(node);\n            } else {\n              mesh.setParent(node);\n            }\n          });\n        }\n      }\n\n      // Reset node if instanced to not duplicate transforms\n      if (isInstancedMatrix) {\n        // Remove unused nodes just providing an instance transform\n        if (!isFirstInstance) return null;\n        // Avoid duplicate transform for node containing the instanced mesh\n        node.matrix.identity();\n        node.decompose();\n      }\n      return node;\n    });\n    desc.nodes.forEach((_ref14, i) => {\n      let {\n        children = []\n      } = _ref14;\n      // Set hierarchy now all nodes created\n      children.forEach(childIndex => {\n        if (!nodes[childIndex]) return;\n        nodes[childIndex].setParent(nodes[i]);\n      });\n    });\n\n    // Add frustum culling for instances now that instanceMatrix attribute is populated\n    meshes.forEach((_ref15, i) => {\n      let {\n        primitives\n      } = _ref15;\n      primitives.forEach((primitive, i) => {\n        if (primitive.isInstancedMesh) primitive.addFrustumCull();\n      });\n    });\n    return [nodes, cameras];\n  }\n  static populateSkins(skins, nodes) {\n    if (!skins) return;\n    skins.forEach(skin => {\n      skin.joints = skin.joints.map((i, index) => {\n        const joint = nodes[i];\n        joint.skin = skin;\n        joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n        return joint;\n      });\n      if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n    });\n  }\n  static parseAnimations(gl, desc, nodes, bufferViews) {\n    if (!desc.animations) return null;\n    return desc.animations.map((_ref16, animationIndex) => {\n      let {\n        channels,\n        // required\n        samplers,\n        // required\n        name // optional\n        // extensions, // optional\n        // extras,  // optional\n      } = _ref16;\n      const data = channels.map(_ref17 => {\n        let {\n          sampler: samplerIndex,\n          // required\n          target // required\n          // extensions, // optional\n          // extras, // optional\n        } = _ref17;\n        const {\n          input: inputIndex,\n          // required\n          interpolation = 'LINEAR',\n          output: outputIndex // required\n          // extensions, // optional\n          // extras, // optional\n        } = samplers[samplerIndex];\n        const {\n          node: nodeIndex,\n          // optional - TODO: when is it not included?\n          path // required\n          // extensions, // optional\n          // extras, // optional\n        } = target;\n        const node = nodes[nodeIndex];\n        const transform = TRANSFORMS[path];\n        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n        // Store reference on node for cyclical retrieval\n        if (!node.animations) node.animations = [];\n        if (!node.animations.includes(animationIndex)) node.animations.push(animationIndex);\n        return {\n          node,\n          transform,\n          interpolation,\n          times,\n          values\n        };\n      });\n      return {\n        name,\n        animation: new GLTFAnimation(data)\n      };\n    });\n  }\n  static parseScenes(desc, nodes) {\n    if (!desc.scenes) return null;\n    return desc.scenes.map(_ref18 => {\n      let {\n        nodes: nodesIndices = [],\n        name,\n        // optional\n        extensions,\n        extras\n      } = _ref18;\n      const scene = nodesIndices.reduce((map, i) => {\n        // Don't add null nodes (instanced transforms)\n        if (nodes[i]) map.push(nodes[i]);\n        return map;\n      }, []);\n      scene.extras = extras;\n      return scene;\n    });\n  }\n  static parseLights(gl, desc, nodes, scenes) {\n    const lights = {\n      directional: [],\n      point: [],\n      spot: []\n    };\n\n    // Update matrices on root nodes\n    scenes.forEach(scene => scene.forEach(node => node.updateMatrixWorld()));\n\n    // Uses KHR_lights_punctual extension\n    const lightsDescArray = desc.extensions?.KHR_lights_punctual?.lights || [];\n\n    // Need nodes for transforms\n    nodes.forEach(node => {\n      if (!node?.extensions?.KHR_lights_punctual) return;\n      const lightIndex = node.extensions.KHR_lights_punctual.light;\n      const lightDesc = lightsDescArray[lightIndex];\n      const light = {\n        name: lightDesc.name || '',\n        color: {\n          value: new Vec3().set(lightDesc.color || 1)\n        }\n      };\n      // Apply intensity directly to color\n      if (lightDesc.intensity !== undefined) light.color.value.multiply(lightDesc.intensity);\n      switch (lightDesc.type) {\n        case 'directional':\n          light.direction = {\n            value: new Vec3(0, 0, 1).transformDirection(node.worldMatrix)\n          };\n          break;\n        case 'point':\n          light.position = {\n            value: new Vec3().applyMatrix4(node.worldMatrix)\n          };\n          light.distance = {\n            value: lightDesc.range\n          };\n          light.decay = {\n            value: 2\n          };\n          break;\n        case 'spot':\n          // TODO: support spot uniforms\n          Object.assign(light, lightDesc);\n          break;\n      }\n      lights[lightDesc.type].push(light);\n    });\n    return lights;\n  }\n}","map":{"version":3,"names":["Geometry","Transform","Texture","Mesh","Camera","GLTFAnimation","GLTFSkin","Mat4","Vec3","NormalProgram","InstancedMesh","TYPE_ARRAY","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","TYPE_SIZE","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","TRANSFORMS","translation","rotation","scale","GLTFLoader","setDracoManager","manager","dracoManager","setBasisManager","basisManager","load","gl","src","dir","split","slice","join","desc","parseDesc","parse","asset","undefined","version","console","warn","extensionsRequired","includes","buffers","loadBuffers","renderer","bindVertexArray","bufferViews","parseBufferViews","images","parseImages","textures","parseTextures","materials","parseMaterials","skins","parseSkins","meshes","parseMeshes","nodes","cameras","parseNodes","populateSkins","animations","parseAnimations","scenes","parseScenes","scene","lights","parseLights","i","length","splice","json","fetch","mode","then","res","arrayBuffer","data","textDecoder","TextDecoder","decode","unpackGLB","JSON","glb","header","Error","jsonChunkHeader","jsonByteOffset","jsonByteLength","jsonText","byteLength","binaryChunkHeader","binaryByteOffset","binaryByteLength","binary","resolveURI","uri","test","replace","Promise","all","map","buffer","forEach","_ref","primitives","_ref2","attributes","indices","extensions","attr","accessor","accessors","bufferView","KHR_draco_mesh_compression","isDraco","isAttribute","target","ELEMENT_ARRAY_BUFFER","_ref3","bufferViewIndex","componentType","_ref4","mimeType","_ref5","bufferIndex","byteOffset","byteStride","ARRAY_BUFFER","name","extras","createBuffer","bindBuffer","state","boundBuffer","bufferData","STATIC_DRAW","_ref6","image","parseTexture","Image","blob","Blob","type","URL","createObjectURL","ready","onload","textureInfo","createTexture","_ref7","sampler","samplerIndex","source","sourceIndex","EXT_texture_webp","KHR_texture_basisu","texture","options","flipY","wrapS","REPEAT","wrapT","samplers","prop","isBasis","internalFormat","isCompressedTexture","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","_ref8","pbrMetallicRoughness","normalTexture","occlusionTexture","emissiveTexture","emissiveFactor","alphaMode","alphaCutoff","doubleSided","baseColorFactor","baseColorTexture","metallicFactor","roughnessFactor","metallicRoughnessTexture","index","_ref9","inverseBindMatrices","skeleton","joints","parseAccessor","_ref0","meshIndex","weights","numInstances","skinIndices","isLightmap","_ref1","mesh","skin","push","lightmap_scale_offset","isSkin","skinIndex","parsePrimitives","_ref10","geometry","program","frustumCulled","instanceCount","_ref11","meshConstructor","instanceMatrix","_ref12","material","materialIndex","targets","gltfMaterial","gltfAttributeMap","attributeMap","attributeTypeMap","attributeTypeNameMap","attributeNormalizedMap","attributeName","normalized","geometryData","decodeGeometry","attributeIds","attributeTypes","result","array","size","itemSize","addAttribute","instanced","count","min","max","sparse","bufferByteOffset","TypeArray","elementBytes","BYTES_PER_ELEMENT","componentStride","isInterleaved","filteredData","typedData","start","end","set","stride","offset","_ref13","camera","children","matrix","isCamera","node","cameraOpts","yfov","fov","znear","near","zfar","far","perspective","Math","PI","xmag","ymag","orthographic","left","right","top","bottom","lightmapTexture","copy","decompose","quaternion","position","updateMatrix","isInstanced","isFirstInstance","isInstancedMatrix","Object","assign","setParent","toArray","lightmapScaleOffset","needsUpdate","identity","_ref14","childIndex","_ref15","primitive","isInstancedMesh","addFrustumCull","joint","bindInverse","_ref16","animationIndex","channels","_ref17","input","inputIndex","interpolation","output","outputIndex","nodeIndex","path","transform","times","values","animation","_ref18","nodesIndices","reduce","directional","point","spot","updateMatrixWorld","lightsDescArray","KHR_lights_punctual","lightIndex","light","lightDesc","color","value","intensity","multiply","direction","transformDirection","worldMatrix","applyMatrix4","distance","range","decay"],"sources":["/Users/apple/Desktop/MovieZone/node_modules/ogl/src/extras/GLTFLoader.js"],"sourcesContent":["import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Camera } from '../core/Camera.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { NormalProgram } from './NormalProgram.js';\nimport { InstancedMesh } from './InstancedMesh.js';\n\n// TODO\n// [ ] Morph targets\n// [ ] Materials\n// [ ] Sparse accessor packing? For morph targets basically\n// [ ] Option to turn off GPU instancing?\n// [ ] Spot lights\n\nconst TYPE_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n    'image/jpeg': Uint8Array,\n    'image/png': Uint8Array,\n    'image/webp': Uint8Array,\n};\n\nconst TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n};\n\nconst TRANSFORMS = {\n    translation: 'position',\n    rotation: 'quaternion',\n    scale: 'scale',\n};\n\nexport class GLTFLoader {\n    static setDracoManager(manager) {\n        this.dracoManager = manager;\n    }\n\n    static setBasisManager(manager) {\n        this.basisManager = manager;\n    }\n\n    static async load(gl, src) {\n        const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n        // Load main description json\n        const desc = await this.parseDesc(src);\n\n        return this.parse(gl, desc, dir);\n    }\n\n    static async parse(gl, desc, dir) {\n        if (desc.asset === undefined || desc.asset.version[0] < 2)\n            console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n\n        if (desc.extensionsRequired?.includes('KHR_draco_mesh_compression') && !this.dracoManager)\n            console.warn('KHR_draco_mesh_compression extension required but no manager supplied. Use .setDracoManager()');\n\n        if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager)\n            console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n        // Load buffers async\n        const buffers = await this.loadBuffers(desc, dir);\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        gl.renderer.bindVertexArray(null);\n\n        // Create gl buffers from bufferViews\n        const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n        // Create images from either bufferViews or separate image files\n        const images = await this.parseImages(gl, desc, dir, bufferViews);\n\n        const textures = this.parseTextures(gl, desc, images);\n\n        // Just pass through material data for now\n        const materials = this.parseMaterials(gl, desc, textures);\n\n        // Fetch the inverse bind matrices for skeleton joints\n        const skins = this.parseSkins(gl, desc, bufferViews);\n\n        // Create geometries for each mesh primitive\n        const meshes = await this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n        // Create transforms, meshes and hierarchy\n        const [nodes, cameras] = this.parseNodes(gl, desc, meshes, skins, images);\n\n        // Place nodes in skeletons\n        this.populateSkins(skins, nodes);\n\n        // Create animation handlers\n        const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n        // Get top level nodes for each scene\n        const scenes = this.parseScenes(desc, nodes);\n        const scene = scenes[desc.scene];\n\n        // Create uniforms for scene lights (TODO: light linking?)\n        const lights = this.parseLights(gl, desc, nodes, scenes);\n\n        // Remove null nodes (instanced transforms)\n        for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n        return {\n            json: desc,\n            buffers,\n            bufferViews,\n            cameras,\n            images,\n            textures,\n            materials,\n            meshes,\n            nodes,\n            lights,\n            animations,\n            scenes,\n            scene,\n        };\n    }\n\n    static parseDesc(src) {\n        return fetch(src, { mode: 'cors' })\n            .then((res) => res.arrayBuffer())\n            .then((data) => {\n                const textDecoder = new TextDecoder();\n                if (textDecoder.decode(new Uint8Array(data, 0, 4)) === 'glTF') {\n                    return this.unpackGLB(data);\n                } else {\n                    return JSON.parse(textDecoder.decode(data));\n                }\n            });\n    }\n\n    // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n    static unpackGLB(glb) {\n        // Decode and verify GLB header\n        const header = new Uint32Array(glb, 0, 3);\n        if (header[0] !== 0x46546c67) {\n            throw new Error('Invalid glTF asset.');\n        } else if (header[1] !== 2) {\n            throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n        }\n        // Decode and verify chunk headers\n        const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        if (jsonChunkHeader[1] !== 0x4e4f534a) {\n            throw new Error('Unexpected GLB layout.');\n        }\n\n        // Decode JSON\n        const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n        const json = JSON.parse(jsonText);\n        // JSON only\n        if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n\n        const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n        if (binaryChunkHeader[1] !== 0x004e4942) {\n            throw new Error('Unexpected GLB layout.');\n        }\n        // Decode content\n        const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n        const binaryByteLength = binaryChunkHeader[0];\n        const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n        // Attach binary to buffer\n        json.buffers[0].binary = binary;\n        return json;\n    }\n\n    // ThreeJS GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n    static resolveURI(uri, dir) {\n        // Invalid URI\n        if (typeof uri !== 'string' || uri === '') return '';\n\n        // Host Relative URI\n        if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n            dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n        }\n\n        // Absolute URI http://, https://, //\n        if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n        // Data URI\n        if (/^data:.*,.*$/i.test(uri)) return uri;\n\n        // Blob URI\n        if (/^blob:.*$/i.test(uri)) return uri;\n\n        // Relative URI\n        return dir + uri;\n    }\n\n    static loadBuffers(desc, dir) {\n        if (!desc.buffers) return null;\n        return Promise.all(\n            desc.buffers.map((buffer) => {\n                // For GLB, binary buffer ready to go\n                if (buffer.binary) return buffer.binary;\n                const uri = this.resolveURI(buffer.uri, dir);\n                return fetch(uri, { mode: 'cors' }).then((res) => res.arrayBuffer());\n            })\n        );\n    }\n\n    static parseBufferViews(gl, desc, buffers) {\n        if (!desc.bufferViews) return null;\n        const bufferViews = desc.bufferViews;\n\n        desc.meshes &&\n            desc.meshes.forEach(({ primitives }) => {\n                primitives.forEach(({ attributes, indices, extensions }) => {\n                    // Flag bufferView as an attribute, so it knows to create a gl buffer\n                    for (const attr in attributes) {\n                        const accessor = desc.accessors[attributes[attr]];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n                    }\n\n                    if (indices !== undefined) {\n                        const accessor = desc.accessors[indices];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n\n                        // Make sure indices bufferView have a target property for gl buffer binding\n                        bufferViews[accessor.bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n                    }\n                });\n            });\n\n        // Get componentType of each bufferView from the accessors\n        desc.accessors.forEach(({ bufferView: bufferViewIndex, componentType }) => {\n            if (bufferViewIndex === undefined) return;\n            bufferViews[bufferViewIndex].componentType = componentType;\n        });\n\n        // Get mimetype of bufferView from images\n        desc.images &&\n            desc.images.forEach(({ uri, bufferView: bufferViewIndex, mimeType }) => {\n                if (bufferViewIndex === undefined) return;\n                bufferViews[bufferViewIndex].mimeType = mimeType;\n            });\n\n        // Push each bufferView to the GPU as a separate buffer\n        bufferViews.forEach(\n            (\n                {\n                    buffer: bufferIndex, // required\n                    byteOffset = 0, // optional\n                    byteLength, // required\n                    byteStride, // optional\n                    target = gl.ARRAY_BUFFER, // optional, added above for elements\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n\n                    componentType, // optional, added from accessor above\n                    mimeType, // optional, added from images above\n                    isAttribute,\n                    isDraco,\n                },\n                i\n            ) => {\n                bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n\n                if (!isAttribute || isDraco) return;\n                // Create gl buffers for the bufferView, pushing it to the GPU\n                const buffer = gl.createBuffer();\n                gl.bindBuffer(target, buffer);\n                gl.renderer.state.boundBuffer = buffer;\n                gl.bufferData(target, bufferViews[i].data, gl.STATIC_DRAW);\n                bufferViews[i].buffer = buffer;\n            }\n        );\n\n        return bufferViews;\n    }\n\n    static parseImages(gl, desc, dir, bufferViews) {\n        if (!desc.images) return null;\n        return Promise.all(\n            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {\n                if (mimeType === 'image/ktx2') {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const image = await this.basisManager.parseTexture(data);\n                    return image;\n                }\n\n                // jpg / png / webp\n                const image = new Image();\n                image.name = name;\n                if (uri) {\n                    image.src = this.resolveURI(uri, dir);\n                } else if (bufferViewIndex !== undefined) {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const blob = new Blob([data], { type: mimeType });\n                    image.src = URL.createObjectURL(blob);\n                }\n                image.ready = new Promise((res) => {\n                    image.onload = () => res();\n                });\n                return image;\n            })\n        );\n    }\n\n    static parseTextures(gl, desc, images) {\n        if (!desc.textures) return null;\n        return desc.textures.map((textureInfo) => this.createTexture(gl, desc, images, textureInfo));\n    }\n\n    static createTexture(gl, desc, images, { sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) {\n        if (sourceIndex === undefined && !!extensions) {\n            // WebP extension source index\n            if (extensions.EXT_texture_webp) sourceIndex = extensions.EXT_texture_webp.source;\n\n            // Basis extension source index\n            if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n        }\n\n        const image = images[sourceIndex];\n        if (image.texture) return image.texture;\n\n        const options = {\n            flipY: false,\n            wrapS: gl.REPEAT, // Repeat by default, opposed to OGL's clamp by default\n            wrapT: gl.REPEAT,\n        };\n        const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n        if (sampler) {\n            ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {\n                if (sampler[prop]) options[prop] = sampler[prop];\n            });\n        }\n\n        // For compressed textures\n        if (image.isBasis) {\n            options.image = image;\n            options.internalFormat = image.internalFormat;\n            if (image.isCompressedTexture) {\n                options.generateMipmaps = false;\n                if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n            }\n            const texture = new Texture(gl, options);\n            texture.name = name;\n            image.texture = texture;\n            return texture;\n        }\n\n        const texture = new Texture(gl, options);\n        texture.name = name;\n        image.texture = texture;\n        image.ready.then(() => {\n            texture.image = image;\n        });\n\n        return texture;\n    }\n\n    static parseMaterials(gl, desc, textures) {\n        if (!desc.materials) return null;\n        return desc.materials.map(\n            ({\n                name,\n                extensions,\n                extras,\n                pbrMetallicRoughness = {},\n                normalTexture,\n                occlusionTexture,\n                emissiveTexture,\n                emissiveFactor = [0, 0, 0],\n                alphaMode = 'OPAQUE',\n                alphaCutoff = 0.5,\n                doubleSided = false,\n            }) => {\n                const {\n                    baseColorFactor = [1, 1, 1, 1],\n                    baseColorTexture,\n                    metallicFactor = 1,\n                    roughnessFactor = 1,\n                    metallicRoughnessTexture,\n                    //   extensions,\n                    //   extras,\n                } = pbrMetallicRoughness;\n\n                if (baseColorTexture) {\n                    baseColorTexture.texture = textures[baseColorTexture.index];\n                    // texCoord\n                }\n                if (normalTexture) {\n                    normalTexture.texture = textures[normalTexture.index];\n                    // scale: 1\n                    // texCoord\n                }\n                if (metallicRoughnessTexture) {\n                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n                    // texCoord\n                }\n                if (occlusionTexture) {\n                    occlusionTexture.texture = textures[occlusionTexture.index];\n                    // strength 1\n                    // texCoord\n                }\n                if (emissiveTexture) {\n                    emissiveTexture.texture = textures[emissiveTexture.index];\n                    // texCoord\n                }\n\n                return {\n                    name,\n                    extensions,\n                    extras,\n                    baseColorFactor,\n                    baseColorTexture,\n                    metallicFactor,\n                    roughnessFactor,\n                    metallicRoughnessTexture,\n                    normalTexture,\n                    occlusionTexture,\n                    emissiveTexture,\n                    emissiveFactor,\n                    alphaMode,\n                    alphaCutoff,\n                    doubleSided,\n                };\n            }\n        );\n    }\n\n    static parseSkins(gl, desc, bufferViews) {\n        if (!desc.skins) return null;\n        return desc.skins.map(\n            ({\n                inverseBindMatrices, // optional\n                skeleton, // optional\n                joints, // required\n                // name,\n                // extensions,\n                // extras,\n            }) => {\n                return {\n                    inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n                    skeleton,\n                    joints,\n                };\n            }\n        );\n    }\n\n    static parseMeshes(gl, desc, bufferViews, materials, skins) {\n        if (!desc.meshes) return null;\n        return Promise.all(\n            desc.meshes.map(\n                async (\n                    {\n                        primitives, // required\n                        weights, // optional\n                        name, // optional\n                        extensions, // optional\n                        extras = {}, // optional - will get merged with node extras\n                    },\n                    meshIndex\n                ) => {\n                    // TODO: weights stuff?\n                    // Parse through nodes to see how many instances there are and if there is a skin attached\n                    // If multiple instances of a skin, need to create each\n                    let numInstances = 0;\n                    let skinIndices = [];\n                    let isLightmap = false;\n                    desc.nodes &&\n                        desc.nodes.forEach(({ mesh, skin, extras }) => {\n                            if (mesh === meshIndex) {\n                                numInstances++;\n                                if (skin !== undefined) skinIndices.push(skin);\n                                if (extras && extras.lightmap_scale_offset) isLightmap = true;\n                            }\n                        });\n                    let isSkin = !!skinIndices.length;\n\n                    // For skins, return array of skin meshes to account for multiple instances\n                    if (isSkin) {\n                        primitives = await Promise.all(\n                            skinIndices.map(async (skinIndex) => {\n                                return (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, 1, isLightmap)).map(({ geometry, program, mode }) => {\n                                    const mesh = new GLTFSkin(gl, { skeleton: skins[skinIndex], geometry, program, mode });\n                                    mesh.name = name;\n                                    mesh.extras = extras;\n                                    if (extensions) mesh.extensions = extensions;\n                                    // TODO: support skin frustum culling\n                                    mesh.frustumCulled = false;\n                                    return mesh;\n                                });\n                            })\n                        );\n                        // For retrieval to add to node\n                        primitives.instanceCount = 0;\n                        primitives.numInstances = numInstances;\n                    } else {\n                        primitives = (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap)).map(({ geometry, program, mode }) => {\n                            // InstancedMesh class has custom frustum culling for instances\n                            const meshConstructor = geometry.attributes.instanceMatrix ? InstancedMesh : Mesh;\n                            const mesh = new meshConstructor(gl, { geometry, program, mode });\n                            mesh.name = name;\n                            mesh.extras = extras;\n                            if (extensions) mesh.extensions = extensions;\n                            // Tag mesh so that nodes can add their transforms to the instance attribute\n                            mesh.numInstances = numInstances;\n                            return mesh;\n                        });\n                    }\n\n                    return {\n                        primitives,\n                        weights,\n                        name,\n                    };\n                }\n            )\n        );\n    }\n\n    static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap) {\n        return Promise.all(\n            primitives.map(\n                async ({\n                    attributes, // required\n                    indices, // optional\n                    material: materialIndex, // optional\n                    mode = 4, // optional\n                    targets, // optional\n                    extensions, // optional\n                    extras, // optional\n                }) => {\n                    // TODO: materials\n                    const program = new NormalProgram(gl);\n                    if (materialIndex !== undefined) {\n                        program.gltfMaterial = materials[materialIndex];\n                    }\n\n                    const geometry = new Geometry(gl);\n                    if (extras) geometry.extras = extras;\n                    if (extensions) geometry.extensions = extensions;\n\n                    // For compressed geometry data\n                    if (extensions && extensions.KHR_draco_mesh_compression) {\n                        const bufferViewIndex = extensions.KHR_draco_mesh_compression.bufferView;\n                        const gltfAttributeMap = extensions.KHR_draco_mesh_compression.attributes;\n                        const attributeMap = {};\n                        const attributeTypeMap = {};\n                        const attributeTypeNameMap = {};\n                        const attributeNormalizedMap = {};\n\n                        for (const attr in attributes) {\n                            const accessor = desc.accessors[attributes[attr]];\n                            const attributeName = ATTRIBUTES[attr];\n                            attributeMap[attributeName] = gltfAttributeMap[attr];\n                            attributeTypeMap[attributeName] = accessor.componentType;\n                            attributeTypeNameMap[attributeName] = TYPE_ARRAY[accessor.componentType].name;\n                            attributeNormalizedMap[attributeName] = accessor.normalized === true;\n                        }\n\n                        const { data } = bufferViews[bufferViewIndex];\n                        const geometryData = await this.dracoManager.decodeGeometry(data, {\n                            attributeIds: attributeMap,\n                            attributeTypes: attributeTypeNameMap,\n                        });\n\n                        // Add each attribute result\n                        for (let i = 0; i < geometryData.attributes.length; i++) {\n                            const result = geometryData.attributes[i];\n                            const name = result.name;\n                            const data = result.array;\n                            const size = result.itemSize;\n                            const type = attributeTypeMap[name];\n                            const normalized = attributeNormalizedMap[name];\n\n                            // Create gl buffers for the attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute(name, {\n                                data,\n                                size,\n                                type,\n                                normalized,\n                                buffer,\n                            });\n                        }\n\n                        // Add index attribute if found\n                        if (geometryData.index) {\n                            const data = geometryData.index.array;\n                            const size = geometryData.index.itemSize;\n\n                            // Create gl buffers for the index attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute('index', {\n                                data,\n                                size,\n                                type: 5125, // Uint32Array\n                                normalized: false,\n                                buffer,\n                            });\n                        }\n                    } else {\n                        // Add each attribute found in primitive\n                        for (const attr in attributes) {\n                            geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n                        }\n\n                        // Add index attribute if found\n                        if (indices !== undefined) {\n                            geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n                        }\n                    }\n\n                    // Add instanced transform attribute if multiple instances\n                    // Ignore if skin as we don't support instanced skins out of the box\n                    if (numInstances > 1) {\n                        geometry.addAttribute('instanceMatrix', {\n                            instanced: 1,\n                            size: 16,\n                            data: new Float32Array(numInstances * 16),\n                        });\n                    }\n\n                    // Always supply lightmapScaleOffset as an instanced attribute\n                    // Instanced skin lightmaps not supported\n                    if (isLightmap) {\n                        geometry.addAttribute('lightmapScaleOffset', {\n                            instanced: 1,\n                            size: 4,\n                            data: new Float32Array(numInstances * 4),\n                        });\n                    }\n\n                    return {\n                        geometry,\n                        program,\n                        mode,\n                    };\n                }\n            )\n        );\n    }\n\n    static parseAccessor(index, desc, bufferViews) {\n        // TODO: init missing bufferView with 0s\n        // TODO: support sparse\n\n        const {\n            bufferView: bufferViewIndex, // optional\n            byteOffset = 0, // optional\n            componentType, // required\n            normalized = false, // optional\n            count, // required\n            type, // required\n            min, // optional\n            max, // optional\n            sparse, // optional\n            // name, // optional\n            // extensions, // optional\n            // extras, // optional\n        } = desc.accessors[index];\n\n        const {\n            data, // attached in parseBufferViews\n            buffer, // replaced to be the actual GL buffer\n            byteOffset: bufferByteOffset = 0,\n            // byteLength, // applied in parseBufferViews\n            byteStride = 0,\n            target,\n            // name,\n            // extensions,\n            // extras,\n        } = bufferViews[bufferViewIndex];\n\n        const size = TYPE_SIZE[type];\n\n        // Parse data from joined buffers\n        const TypeArray = TYPE_ARRAY[componentType];\n        const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n        const componentStride = byteStride / elementBytes;\n        const isInterleaved = !!byteStride && componentStride !== size;\n\n        let filteredData;\n\n        // Convert data to typed array for various uses (bounding boxes, raycasting, animation, merging etc)\n        if (isInterleaved) {\n            // First convert entire buffer to type\n            const typedData = new TypeArray(data, byteOffset);\n            // TODO: add length to not copy entire buffer if can help it\n            // const typedData = new TypeArray(data, byteOffset, (count - 1) * componentStride)\n\n            // Create output with length\n            filteredData = new TypeArray(count * size);\n\n            // Add element by element\n            for (let i = 0; i < count; i++) {\n                const start = componentStride * i;\n                const end = start + size;\n                filteredData.set(typedData.slice(start, end), i * size);\n            }\n        } else {\n            // Simply a slice\n            filteredData = new TypeArray(data, byteOffset, count * size);\n        }\n\n        // Return attribute data\n        return {\n            data: filteredData,\n            size,\n            type: componentType,\n            normalized,\n            buffer,\n            stride: byteStride,\n            offset: byteOffset,\n            count,\n            min,\n            max,\n        };\n    }\n\n    static parseNodes(gl, desc, meshes, skins, images) {\n        if (!desc.nodes) return null;\n        const cameras = [];\n        const nodes = desc.nodes.map(\n            ({\n                camera, // optional\n                children, // optional\n                skin: skinIndex, // optional\n                matrix, // optional\n                mesh: meshIndex, // optional\n                rotation, // optional\n                scale, // optional\n                translation, // optional\n                weights, // optional\n                name, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const isCamera = camera !== undefined;\n\n                const node = isCamera ? new Camera(gl) : new Transform();\n\n                if (isCamera) {\n                    // NOTE: chose to use node's name and extras/extensions over camera\n                    const cameraOpts = desc.cameras[camera];\n                    if (cameraOpts.type === 'perspective') {\n                        const { yfov: fov, znear: near, zfar: far } = cameraOpts.perspective;\n                        node.perspective({ fov: fov * (180 / Math.PI), near, far });\n                    } else {\n                        const { xmag, ymag, znear: near, zfar: far } = cameraOpts.orthographic;\n                        node.orthographic({ near, far, left: -xmag, right: xmag, top: -ymag, bottom: ymag });\n                    }\n                    cameras.push(node);\n                }\n\n                if (name) node.name = name;\n                if (extras) node.extras = extras;\n                if (extensions) node.extensions = extensions;\n\n                // Need to attach to node as may have same material but different lightmap\n                if (extras && extras.lightmapTexture !== undefined) {\n                    extras.lightmapTexture.texture = this.createTexture(gl, desc, images, { source: extras.lightmapTexture.index });\n                }\n\n                // Apply transformations\n                if (matrix) {\n                    node.matrix.copy(matrix);\n                    node.decompose();\n                } else {\n                    if (rotation) node.quaternion.copy(rotation);\n                    if (scale) node.scale.copy(scale);\n                    if (translation) node.position.copy(translation);\n                    node.updateMatrix();\n                }\n\n                // Flags for avoiding duplicate transforms and removing unused instance nodes\n                let isInstanced = false;\n                let isFirstInstance = true;\n                let isInstancedMatrix = false;\n                let isSkin = skinIndex !== undefined;\n\n                // Add mesh if included\n                if (meshIndex !== undefined) {\n                    if (isSkin) {\n                        meshes[meshIndex].primitives[meshes[meshIndex].primitives.instanceCount].forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n                            mesh.setParent(node);\n                        });\n                        meshes[meshIndex].primitives.instanceCount++;\n                        // Remove properties once all instances added\n                        if (meshes[meshIndex].primitives.instanceCount === meshes[meshIndex].primitives.numInstances) {\n                            delete meshes[meshIndex].primitives.numInstances;\n                            delete meshes[meshIndex].primitives.instanceCount;\n                        }\n                    } else {\n                        meshes[meshIndex].primitives.forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n\n                            // Instanced mesh might only have 1\n                            if (mesh.geometry.isInstanced) {\n                                isInstanced = true;\n                                if (!mesh.instanceCount) {\n                                    mesh.instanceCount = 0;\n                                } else {\n                                    isFirstInstance = false;\n                                }\n                                if (mesh.geometry.attributes.instanceMatrix) {\n                                    isInstancedMatrix = true;\n                                    node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n                                }\n\n                                if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                    mesh.geometry.attributes.lightmapScaleOffset.data.set(extras.lightmap_scale_offset, mesh.instanceCount * 4);\n                                }\n\n                                mesh.instanceCount++;\n\n                                if (mesh.instanceCount === mesh.numInstances) {\n                                    // Remove properties once all instances added\n                                    delete mesh.numInstances;\n                                    delete mesh.instanceCount;\n                                    // Flag attribute as dirty\n                                    if (mesh.geometry.attributes.instanceMatrix) {\n                                        mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                                    }\n                                    if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                        mesh.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                                    }\n                                }\n                            }\n\n                            // For instances, only the first node will actually have the mesh\n                            if (isInstanced) {\n                                if (isFirstInstance) mesh.setParent(node);\n                            } else {\n                                mesh.setParent(node);\n                            }\n                        });\n                    }\n                }\n\n                // Reset node if instanced to not duplicate transforms\n                if (isInstancedMatrix) {\n                    // Remove unused nodes just providing an instance transform\n                    if (!isFirstInstance) return null;\n                    // Avoid duplicate transform for node containing the instanced mesh\n                    node.matrix.identity();\n                    node.decompose();\n                }\n\n                return node;\n            }\n        );\n\n        desc.nodes.forEach(({ children = [] }, i) => {\n            // Set hierarchy now all nodes created\n            children.forEach((childIndex) => {\n                if (!nodes[childIndex]) return;\n                nodes[childIndex].setParent(nodes[i]);\n            });\n        });\n\n        // Add frustum culling for instances now that instanceMatrix attribute is populated\n        meshes.forEach(({ primitives }, i) => {\n            primitives.forEach((primitive, i) => {\n                if (primitive.isInstancedMesh) primitive.addFrustumCull();\n            });\n        });\n\n        return [nodes, cameras];\n    }\n\n    static populateSkins(skins, nodes) {\n        if (!skins) return;\n        skins.forEach((skin) => {\n            skin.joints = skin.joints.map((i, index) => {\n                const joint = nodes[i];\n                joint.skin = skin;\n                joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n                return joint;\n            });\n            if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n        });\n    }\n\n    static parseAnimations(gl, desc, nodes, bufferViews) {\n        if (!desc.animations) return null;\n        return desc.animations.map(\n            (\n                {\n                    channels, // required\n                    samplers, // required\n                    name, // optional\n                    // extensions, // optional\n                    // extras,  // optional\n                },\n                animationIndex\n            ) => {\n                const data = channels.map(\n                    ({\n                        sampler: samplerIndex, // required\n                        target, // required\n                        // extensions, // optional\n                        // extras, // optional\n                    }) => {\n                        const {\n                            input: inputIndex, // required\n                            interpolation = 'LINEAR',\n                            output: outputIndex, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = samplers[samplerIndex];\n\n                        const {\n                            node: nodeIndex, // optional - TODO: when is it not included?\n                            path, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = target;\n\n                        const node = nodes[nodeIndex];\n                        const transform = TRANSFORMS[path];\n                        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n                        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n                        // Store reference on node for cyclical retrieval\n                        if (!node.animations) node.animations = [];\n                        if (!node.animations.includes(animationIndex)) node.animations.push(animationIndex);\n\n                        return {\n                            node,\n                            transform,\n                            interpolation,\n                            times,\n                            values,\n                        };\n                    }\n                );\n\n                return {\n                    name,\n                    animation: new GLTFAnimation(data),\n                };\n            }\n        );\n    }\n\n    static parseScenes(desc, nodes) {\n        if (!desc.scenes) return null;\n        return desc.scenes.map(\n            ({\n                nodes: nodesIndices = [],\n                name, // optional\n                extensions,\n                extras,\n            }) => {\n                const scene = nodesIndices.reduce((map, i) => {\n                    // Don't add null nodes (instanced transforms)\n                    if (nodes[i]) map.push(nodes[i]);\n                    return map;\n                }, []);\n                scene.extras = extras;\n                return scene;\n            }\n        );\n    }\n\n    static parseLights(gl, desc, nodes, scenes) {\n        const lights = {\n            directional: [],\n            point: [],\n            spot: [],\n        };\n\n        // Update matrices on root nodes\n        scenes.forEach((scene) => scene.forEach((node) => node.updateMatrixWorld()));\n\n        // Uses KHR_lights_punctual extension\n        const lightsDescArray = desc.extensions?.KHR_lights_punctual?.lights || [];\n\n        // Need nodes for transforms\n        nodes.forEach((node) => {\n            if (!node?.extensions?.KHR_lights_punctual) return;\n            const lightIndex = node.extensions.KHR_lights_punctual.light;\n            const lightDesc = lightsDescArray[lightIndex];\n            const light = {\n                name: lightDesc.name || '',\n                color: { value: new Vec3().set(lightDesc.color || 1) },\n            };\n            // Apply intensity directly to color\n            if (lightDesc.intensity !== undefined) light.color.value.multiply(lightDesc.intensity);\n\n            switch (lightDesc.type) {\n                case 'directional':\n                    light.direction = { value: new Vec3(0, 0, 1).transformDirection(node.worldMatrix) };\n                    break;\n                case 'point':\n                    light.position = { value: new Vec3().applyMatrix4(node.worldMatrix) };\n                    light.distance = { value: lightDesc.range };\n                    light.decay = { value: 2 };\n                    break;\n                case 'spot':\n                    // TODO: support spot uniforms\n                    Object.assign(light, lightDesc);\n                    break;\n            }\n\n            lights[lightDesc.type].push(light);\n        });\n\n        return lights;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}